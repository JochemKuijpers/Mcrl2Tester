sort 
	ChuckType = struct A | B | AB;

sort 
	Position = struct Tray | In | Out | Meas | Proj | Empty1 | Empty2;

act 
 	%Signal Communication

	%IO <-> Tray
	init_io_read, init_io_send, signal_init_io: Nat;
	io_done_send, io_done_read, signal_io_done;
	
	%Recipe <-> Tray
	init_recipe_read, init_recipe_send, signal_init_recipe: Nat # ChuckType;
	recipe_done_send, recipe_done_read, signal_recipe_done;

	%IO <-> Recipe
	get_wafer_send, get_wafer_read, signal_get_wafer;
	return_wafer_send, return_wafer_read, signal_return_wafer;
	out_empty_send, out_empty_read, signal_out_empty;
	in_full_send, in_full_read, signal_in_full;
	
	%Recipe Controller actions
	move_r2: Position # Position;
	move_r2_done;
	move_r3: Position # Position;
	move_r3_done;
	
	swap, swap_done;
	measure, measure_done;
	project, project_done;
	
	%Tray Controller actions
	start, calibrate, calibrate_done, tray_done;
	lot_info: Nat # ChuckType;

	%IO Controller actions
	move_r1: Position # Position;
	move_r1_done, premeasure, premeasure_done;

proc GetWaferFromInAndMeasure =
    get_wafer_send .
    in_full_read .
    move_r2(In, Meas) .
    move_r2_done .
    measure .
    measure_done;

proc MoveToOut =
    move_r3(Meas,Out) .
    move_r3_done .
    return_wafer_send .
    out_empty_read;

proc ProjectAndMoveToOut =
    project .
    project_done .
    swap .
    swap_done .
    MoveToOut;

proc ProcessAorB =
    GetWaferFromInAndMeasure .
    swap .
    swap_done .
    ProjectAndMoveToOut;

proc ProcessAandB =
    GetWaferFromInAndMeasure .
    ProjectAndMoveToOut;

% InitAandB
% chuck A is at the Meas position. move dummy away
% get first wafer
% swap
% do not project
% move second dummy away
proc InitAandB =
    InitA .
    GetWaferFromInAndMeasure .
    swap .
    swap_done .
    %project .
    %project_done .
    move_r3(Meas, Empty2) .
    move_r3_done;

%DeInitAandB
proc DeInitAandB =
    project .
    project_done .
    ProcessAandB .
    move_r2(Empty1, Meas) .
    move_r2_done .
    swap .
    swap_done .
    MoveToOut .
    move_r3(Empty2, Meas) .
    move_r3_done;

%InitA
% chuck A is at the Meas position. move dummy away
proc InitA =
    move_r2(Meas, Empty1) .
    move_r2_done;

%DeInitA
% chuck A is at the Meas position. put dummy back
proc DeInitA =
    move_r2(Empty1, Meas) .
    move_r2_done;

%InitB
% chuck A is at the Meas position. swap first then move away the dummy
proc InitB =
    swap .
    swap_done .
    move_r2(Meas, Empty1) .
    move_r2_done;

%DeInitB
% chuck B is at the Meas position. put dummy back and swap.
proc DeInitB =
    move_r2(Empty1, Meas) .
    move_r2_done .
    swap .
    swap_done;


proc ProcessRecipeAorB(n:Nat, c:ChuckType) =
	(c==A) -> (
	    (n>1) -> (
	        ProcessAorB .
	        ProcessRecipeAorB(max(0, n-1), c)
	    ) <> (
	        ProcessAorB .
	        DeInitA .
	        recipe_done_send .
	        Recipe_controller(0, c)
        )
    ) +
	(c==B) -> (
	    (n>1) -> (
	        ProcessAorB .
	        ProcessRecipeAorB(max(0, n-1), c)
        ) <> (
            ProcessAorB .
            DeInitB .
            recipe_done_send .
            Recipe_controller(0, c)
        )
    );

proc ProcessRecipeAandB(n:Nat, b:Bool) =
	(b) -> (
	    (n>1) -> (
	        ProcessAandB .
	        ProcessRecipeAandB(max(0, n-1), b)
	    ) <> (
	        DeInitAandB .
	        recipe_done_send .
	        Recipe_controller(0, AB)
	    )
	) <> (
	    (n>1) -> (
	        ProcessAandB .
	        ProcessRecipeAandB(max(0, n-1), b)
	    ) <> (
	        DeInitAandB .
	        swap .
	        swap_done .
	        recipe_done_send .
	        Recipe_controller(0, AB)
	    )
    );

proc Recipe_controller(n:Nat, c:ChuckType) =
	(n==0) -> (
	    sum n:Nat, c:ChuckType .
	    init_recipe_read(n, c) .
	    (
            (c==A) -> (
                InitA .
                ProcessRecipeAorB(n,c)
            ) +
            (c==B) -> (
                InitB .
                ProcessRecipeAorB(n,c)
            ) +
            (c==AB) -> (
                (n==1) -> (
                    InitA .
                    ProcessAorB .
                    DeInitA .
                    recipe_done_send .
                    Recipe_controller(0, c)
                ) <> (
                    ((n mod 2)==0) -> (
                        InitAandB .
                        ProcessRecipeAandB(max(0, n-1), true)
                    ) <> (
                        InitAandB .
                        ProcessRecipeAandB(max(0, n-1), false)
                    )
                )
            )
        )
    ) <> (
        recipe_done_send .
        Recipe_controller(0, AB)
    );
			
proc GetWafer = 
    move_r1(Tray, In) .
    move_r1_done .
    premeasure .
    premeasure_done .
    in_full_send;

proc ReturnWafer = 
    move_r1(Out, Tray) .
    move_r1_done .
    out_empty_send;
													
proc IOProcess(n:Nat, i:Nat) =
    get_wafer_read .
    (n>0) -> (
        GetWafer .
        IOProcess(max(0, n-1), i)
    ) +
    return_wafer_read .
    (i>1) -> (
        ReturnWafer .
        IOProcess(n, max(0, i-1))
    ) <> (
        ReturnWafer .
        io_done_send
    );

proc IO_Controller (n: Nat) = 
    (n==0) -> (
        sum n:Nat .
        init_io_read(n) .
        IO_Controller(n)
    ) +
    (n>0) -> (
        IOProcess(n, n) .
        IO_Controller(0)
    );

proc TrayProcess (n:Nat, c:ChuckType) = 
	calibrate .
	calibrate_done .
	(
		init_io_send(n) .
		init_recipe_send(n, c)
		+
		init_recipe_send(n, c) .
		init_io_send(n)
	) .
	(
		io_done_read .
		recipe_done_read
		+ 
		recipe_done_read .
		io_done_read
	);

proc Tray_Controller (b:Bool) =
    (b==false) -> (
        start .
        Tray_Controller(true)
    ) <> (
        sum n:Nat, c:ChuckType .
        (n<3) -> (
            lot_info(n, c)
        ) .
        (n==0) -> (
            tray_done .
            Tray_Controller(false)
        ) <> (
            TrayProcess(n, c) .
            Tray_Controller(true)
        )
    );

init 
	allow(
	    {
            signal_init_io, signal_init_recipe, signal_recipe_done, signal_get_wafer,
            signal_return_wafer, signal_out_empty, signal_io_done, signal_in_full,
            start, calibrate, calibrate_done, move_r1, move_r1_done, tray_done,
            premeasure, premeasure_done, move_r2, move_r2_done, project, project_done,
            move_r3, move_r3_done, swap, swap_done, measure, measure_done, lot_info
        },
        comm(
            {
                init_recipe_read  | init_recipe_send  -> signal_init_recipe,
                recipe_done_send  | recipe_done_read  -> signal_recipe_done,
                get_wafer_send    | get_wafer_read    -> signal_get_wafer,
                return_wafer_send | return_wafer_read -> signal_return_wafer,
                out_empty_send    | out_empty_read    -> signal_out_empty,
                in_full_send      | in_full_read      -> signal_in_full,
                io_done_send      | io_done_read      -> signal_io_done,
                init_io_send      | init_io_read      -> signal_init_io
            },
            Tray_Controller(false) ||
            IO_Controller(0) ||
            Recipe_controller(0,A)
        )
    );
